---
title: MYSQL数据库复习
date: 2020-07-13 14:32:12
tags: 
- 数据库
- 面试题
description: 复习MYSQL数据库，总结其常见问题。
---



#### 引擎InnoDB和MyISAM底层数据结构

索引都使用B+树作为储存结构，不过innoDB使用聚集性索引，而MyISAM使用非聚集性索引（即索引文件和数据文件分开存储）。

https://www.cnblogs.com/fanguangdexiaoyuer/p/10821646.html

#### InnoDB和MyISAM有什么区别

> - InnoDB支持事物，而MyISAM不支持事物
> - InnoDB支持行级锁，而MyISAM支持表级锁
> - InnoDB支持MVCC, 而MyISAM不支持
> - InnoDB支持外键，而MyISAM不支持
> - InnoDB不支持全文索引，而MyISAM支持。

#### 数据库设计三大范式

- 第一范式: 每个列都不可以再拆分.
- 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 
- 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.

#### 什么情况下检索会失效

- 条件中有or，即使有条件带索引也不会使用；要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引 
- 对于多列索引，如果不是使用的第一部分，则不会使用索引； 
- like查询是以%开头的，不会用到索引； 
- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引； 
- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引；

链接：https://www.nowcoder.com/questionTerminal/c54490590c924c0cbedca54049cbbd47
来源：牛客网

#### 事务的ACID原则

1. **原子性(Atomicity)**：是指一个事务要么全部执行，要么不执行，也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤：1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成。
2. **一致性(Consistency)**：是指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。
3. **独立性(Isolation)**：事务的独立性也称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致，更加具体的来讲，就是事务之间的操作是独立的。
4. **持久性(Durability)**：事务的持久性是指事务执行成功以后，该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。

#### 事务之间的影响

- **脏读**，A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
- **不可重复读**，当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
- **幻读**，A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据，造成"幻觉".
- **更新丢失**，当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。

#### 四种隔离级别

- 读未提交
- 读已提交
- 可重复读
- 串行化

####  **Innodb使用的是哪种隔离级别**

InnoDB默认使用的是可重复读隔离级别.

#### MySQL是如何解决不可重复读隔离级别中的幻读问题的

MVCC（多版本并发控制）

https://draveness.me/database-concurrency-control/

#### **在建立索引的时候,都有哪些需要考虑的因素呢**

建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序。

#### MySQL的锁机制

共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.

排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.

#### innodb的gap锁

gap就是索引树中插入新记录的空隙，Gap锁针对的是非唯一索引，而如果是唯一索引则不会存在Gap锁。

https://amsimple.com/blog/article/72.html

#### **主键使用自增ID还是UUID?**

推荐使用自增ID,不要使用UUID。因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)

如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.

总之,在数据量大一些的情况下,用自增主键性能会好一些。

关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.

#### **字段为什么要求定义为not null**

null值会占用更多的字节,且会在程序中造成很多与预期不符的情况，B+树索引时不会存储NULL值的，所以如果索引的字段可以为NULL，索引的效率会下降很多。

#### **MySQL的binlog**

