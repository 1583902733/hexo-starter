---
title: MYSQL数据库复习
date: 2020-07-13 14:32:12
tags: 
- 数据库
- 面试题
description: 复习MYSQL数据库，总结其常见问题。
---



#### 引擎InnoDB和MyISAM底层数据结构

索引都使用B+树作为储存结构，不过innoDB使用聚集性索引，而MyISAM使用非聚集性索引（即索引文件和数据文件分开存储）。

https://www.cnblogs.com/fanguangdexiaoyuer/p/10821646.html

#### InnoDB和MyISAM有什么区别

> - InnoDB支持事物，而MyISAM不支持事物
> - InnoDB支持行级锁，而MyISAM支持表级锁
> - InnoDB支持MVCC, 而MyISAM不支持
> - InnoDB支持外键，而MyISAM不支持
> - InnoDB不支持全文索引（5.6之后也支持），而MyISAM支持。

#### 数据库设计三大范式

- 第一范式: 每个列都不可以再拆分（字段的原子性）；
- 第二范式: 非主键列完全依赖于主键，而不能是依赖于主键的一部分（主要针对联合主键而言）；
- 第三范式: 每一列数据都和主键直接相关，而不能间接相关。

> 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；
> 通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计。
>
> 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
> 简单的解释，比如你和一个女生约会建立一张表，不用每条约会记录都记录她的身高、体重，将身高体重单独的存在一张表中供查询即可。
>
> 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。
> 打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。

#### MySQL索引问题

https://juejin.im/post/6844903967193825294#heading-13

#### 什么情况下检索会失效

- 条件中有or，即使有条件带索引也不会使用；要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引 
- 对于多列索引，如果不是使用的第一部分，则不会使用索引； 
- like查询是以%开头的，不会用到索引； 
- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引； 
- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引；

链接：https://www.nowcoder.com/questionTerminal/c54490590c924c0cbedca54049cbbd47
来源：牛客网

#### 事务的ACID原则

1. **原子性(Atomicity)**：是指一个事务要么全部执行，要么不执行，也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤：1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成。
2. **一致性(Consistency)**：是指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。
3. **独立性(Isolation)**：事务的独立性也称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致，更加具体的来讲，就是事务之间的操作是独立的。
4. **持久性(Durability)**：事务的持久性是指事务执行成功以后，该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。

#### 事务之间的影响

- **脏读**，A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
- **不可重复读**，当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
- **幻读**，A事务读取了一个范围的内容，而同时B事务在此期间插入了一条数据，造成"幻觉".
- **更新丢失**，当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。

#### 四种隔离级别

- 读未提交
- 读已提交
- 可重复读
- 串行化

####  **Innodb使用的是哪种隔离级别**

InnoDB默认使用的是可重复读隔离级别.

#### MySQL是如何解决不可重复读隔离级别中的幻读问题的

> **快照读**
>
> 我们普通的SELECT语句都是普通读，也就是读取的数据都是事务开始时那个状态的数据，普通读的幻读问题主要是通过MVCC来解决的
>
> **实时读**
>
> SELECT *** FOR UPDATE 在查询时会先申请X锁
>
> SELECT *** IN SHARE MODE 在查询时会先申请S锁
>
> 就是实时读，就是读取的是实时的数据，而不快照数据，读的时候会加Next-Key Lock锁住当前的记录，以及左右两个区间的间隙，这样在读的时候就不能往我们的查询范围插入数据了。

MVCC（多版本并发控制），gap锁，next-key锁

https://draveness.me/database-concurrency-control/

https://zhuanlan.zhihu.com/p/66791480

#### **在建立索引的时候,都有哪些需要考虑的因素呢**

建立索引的时候一般要考虑到字段的使用频率，经常作为条件进行查询的字段比较适合。如果需要建立联合索引的话,还需要考虑联合索引中的顺序。

#### MySQL的锁机制

> 共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.
>
> 排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.
>
> 乐观锁
>
> 悲观锁

#### innodb的gap锁

gap就是索引树中插入新记录的空隙，Gap锁针对的是**非唯一索引**，而如果是唯一索引则不会存在Gap锁。

https://amsimple.com/blog/article/72.html

#### **主键使用自增ID还是UUID?**

推荐使用自增ID,不要使用UUID。因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)

如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.

总之,在数据量大一些的情况下,用自增主键性能会好一些。

关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.

#### **字段为什么要求定义为not null**

null值会占用更多的字节,且会在程序中造成很多与预期不符的情况，B+树索引时不会存储NULL值的，所以如果索引的字段可以为NULL，索引的效率会下降很多。

#### **MySQL的binlog**

binlog是Mysql sever层维护的一种二进制日志，与innodb引擎中的redo/undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以"事务"的形式保存在磁盘中；

作用主要有：

> - 复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的
> - 数据恢复：通过mysqlbinlog工具恢复数据
> - 增量备份

#### 什么是触发器

触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束 ，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更 新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

#### 什么是视图

在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。

视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。

**注释：**数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。**视图的增删改有条件限制。**

#### mysql 临时表、内存表和视图

https://developer.aliyun.com/article/42745

#### drop、truncate、 delete区别

最基本：

- drop直接删掉表。 
- truncate删除表中数据，再插入时自增长id又从1开始。 
- delete删除表中数据，可以加where字句。

#### SQL语句执行很慢的原因

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

https://www.cnblogs.com/myseries/p/10719074.html

#### 全局检索

https://www.jianshu.com/p/645402711dac

#### MySQL技术内幕系列博客

https://blog.csdn.net/weixin_44844089/category_9984144.html

#### innodb的自适应hash

#### join优化

> SNL，最简单的双重循环
>
> INL （Index Nested Loop Join算法），将外层表的结果集作为循环的基础数据，然后循环从该结果集每次一条获取数据作为下一个表的过滤条件去查询数据，然后合并结果。如果有多个表join，那么应该将前面的表的结果集作为循环数据，取结果集中的每一行再到下一个表中继续进行循环匹配，获取结果集并返回给客户端。
>
> BNL（Block Nested-Loop算法），将外层循环的行/结果集存入join buffer，内存循环的每一行数据与整个buffer中的记录做比较，可以减少内层循环的扫描次数