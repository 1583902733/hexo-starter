---
title: 操作系统笔记
date: 2020-07-02
tags: 
- 操作系统
- 面试题
description: 操作系统笔记，记录一些常见的问题。
---



#### **进程内存分布**

1）正文段（代码段）——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；   

2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。    

3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。（这就是为什么全局内置类型变量会初始化，而局部变量就为未初始化的未知值）     

4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）

5）堆——动态存储分。

程序在内存中申请了代码段，全局数据段（初始化和未初始化），栈和堆：程序代码放于代码段，全局变量和静态变量存放在全局数据段中，一直存在直到程序结束，而局部变量都放于临时的栈中，随着作用域的结束随着出栈操作而销毁。malloc和new出来的内存不属于上面提到的程序申请的内存中，而是在系统中申请到的内存，所以如果在程序中没有明确free和delete的话，程序结束后该内存仍不会被释放，造成内存泄漏。
————————————————
c语言种static的作用：https://blog.csdn.net/cc198877/article/details/8844729

#### 堆区和栈区的区别

从以下及各方面进行说明：

申请方式、操作方式、申请后系统的响应 、申请大小的限制、申请效率的比较、堆和栈中的存储内容。

https://blog.csdn.net/shanshanhi/article/details/50904706

#### 函数栈、线程栈和进程栈

#### **内存对齐**

##### 原因

CPU每次寻址都是要消费时间的，如果一次取不完数据就要取多次。比如int类型的变量a占4Byte，假设在内存中没有对齐(所谓对齐，指的是内存中数据的首地址是CPU单次获取数据大小的整数倍)，且存放在0x00000003 - 0x00000006处(0x00000003不是4的整数倍)。那么每次取4字节(32位宽总线)的CPU第一次取到[0x00000000 - 0x00000003]，只得到变量a的1/4数据，进而需要进行第二次取数[0x00000004 - 0x00000007]，为了得到int类型的一个变量，却需要两次访问内存，并且还需要拼接处理，性能较低，这是其一。

有些CPU(ARM架构的)在内存非对齐的情况下，执行二进制代码会崩溃，因为不是所有的硬件平台都能访问任意地址上的任意数据的。倘若代码移植到其他不支持的平台上，不具有可移植性，这是其二。

##### 规则

结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（`#pragma pack(n)`）或当前成员变量类型的长度（`unsafe.Sizeof`），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍；

结构体本身，对齐值必须为编译器默认对齐长度（`#pragma pack(n)`）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值。

https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/go-memory-align

https://zhuanlan.zhihu.com/p/101140160

#### 虚拟内存

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

#### 追踪内存使用情况的两种方法

位图

空闲链表：首次适配算法、下次适配算法、最佳适配算法、最差适配算法、快速适配算法

#### 缺页异常及其常用算法

OPT、FIFO、LRU

https://www.cnblogs.com/sunsky303/p/9214223.html

#### **内核态和用户态，进程上下文和中断上下文**

&emsp;&emsp;当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。

https://www.cnblogs.com/Anker/p/3269106.html

#### 死锁的必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

#### 四种处理死锁的策略

1. 鸵鸟算法，把头埋在沙子里面，假装什么事都没有发生，就是忽略死锁；
2. 检测死锁并恢复，让死锁发生，检测死锁是否发生，一旦发生死锁，采取行动解决死锁；
3. 仔细对资源进行分配，动态的避免死锁，例如银行家算法；
4. 通过破坏死锁的四个必要条件之一，防止死锁的产生。

#### 银行家算法

&emsp;&emsp;在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。

https://www.jianshu.com/p/5d01e5db5eaf

#### **互斥锁和自旋锁的区别**

互斥锁属于sleep-waiting类型的锁，自旋锁则不然，它属于busy-waiting类型的锁。

https://blog.csdn.net/susidian/article/details/51068858

#### 进程线程间的通信方式(IPC)

1. （匿名）管道，半双工通信，只能在有亲缘关系的进程中使用；
2. 有名管道(FIFO)
3. 消息队列，是消息的链表，存放在内核中并由消息队列标识符标识；
4. 信号量，是一个计数器，用于实现进程间的互斥和同步
5. 信号
6.  共享内存
7. 套接字通信

#### 进程间的同步方式用过哪些

信号量和管程

#### 线程间同步

- 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
- 信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。
- 临界区，同一进程内多线程同步。


知乎链接：https://zhuanlan.zhihu.com/p/23755202

https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78591330

#### 进程有哪几种状态

- 就绪状态 ：进程已经获得除处理机以外的全部所需资源，只要获得处理机便可立即执行，则称此时的状态为就绪状态
- 运行状态 ：当进程已经获得处理机，且其程序正在处理机上运行，则称进程此时的状态为运行状态
- 阻塞状态 ：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起阻塞状态的事件可以有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信号等等

#### 操作系统中进程调度策略

- FIFO
- Shortest Job First (SJF)
- Shortest Remaining Job First (SRJF)
- 优先权调度
- Round-Robin(RR)轮转调度算法

#### Docker资源隔离和限制实现原理

http://lionheartwang.github.io/blog/2018/03/18/dockerzi-yuan-ge-chi-he-xian-zhi-shi-xian-yuan-li/

#### 用户态到内核态的切换方式

1. 系统调用：用户态进程主动通过系统调用申请操作系统提供的服务程序
2. 异常：发生了不可预知的异常，切换到内核相关的异常处理程序，如缺页异常
3. 外设中断：外设完成用户请求的操作后向CPU发出中断信号，CPU暂停执行下一条指令，转而执行终端处理程序。如果之前执行的指令是用户态下的程序中的，那么也会发生切换

&emsp;&emsp;大多数文件系统的默认I/O都是缓存I/O，操作系统将数据缓存在文件系统的页缓存中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。因此一次I/O操作，例如`read`发生时会经历两个阶段：

1. 等待数据准备
2. 将数据从内核拷贝到进程

#### select、poll和epoll

<img src="https://pic4.zhimg.com/v2-b23f9ccc4a82c26cc447779aa4427a0e_r.jpg" alt="preview" style="zoom: 50%;" />

对比：https://www.toutiao.com/i6577337431438131720/?tt_from=weixin&utm_campaign=client_share&timestamp=1531477350&app=news_article&utm_source=weixin&iid=37812930096&utm_medium=toutiao_ios&wxshare_count=1#comment_area

#### epoll简介和触发模式

https://www.cnblogs.com/zl-graduate/articles/6724446.html

#### 系统如何提高并发性

1、提高CPU并发计算能力

（1）多进程&多线程

（2）减少进程切换，使用线程，考虑进程绑定CPU

（3）减少使用不必要的锁，考虑无锁编程

（4）考虑进程优先级

（5）关注系统负载

2、改进I/O模型

（1）DMA技术

（2）异步I/O

（3）改进多路I/O就绪通知策略，epoll

（4）Sendfile

（5）内存映射

（6）直接I/O